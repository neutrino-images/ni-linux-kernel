/*
 * Copyright (C) 2014, Entropic Communications. All Rights Reserved
 * Author:
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef TMNXTYPES_H
#define TMNXTYPES_H

#ifdef	_TMtypes_h
/* tmtypes.h was already included, skip defining the types already known */
#define TMOAPTMTYPESINCLUDED
#else
#define	_TMtypes_h
#endif

/*-----------------------------------------------------------------------------
** Project include files:
**-----------------------------------------------------------------------------
** NOTE: tmFlags.h
**  The tmFlags.h header file defines CPU type/model, OS type/version,
**  big/little endianness, and other platform-dependent settings.  The file
**  is automatically generated by the SDE2 build process.  If not using the
**  SDE2 build process, do the following:
**  1)  Obtain a copy of tmFlagsExample.h file from the MoReUse website
**      (URL: http://pww.rtg.sc.philips.com/cmd/html/global_files.html).
**  2)  Rename the file to tmFlags.h and place it in the build include path.
**  3)  Modify the file for your platform settings, using the comments in the
**      file as a guide for the required modifications.
*/
#include "tmFlags.h"                /* DVP platform-dependent build flags */

#include "phStdTypes.h"

#include "phExtraTypes.h"


/*-----------------------------------------------------------------------------
** Standard include files:
**-----------------------------------------------------------------------------
*/


#ifdef __cplusplus
extern "C"
{
#endif

/*-----------------------------------------------------------------------------
** Types and defines:
**-----------------------------------------------------------------------------
**
** NOTE: Bool values
**  TM_TRUE is defined as 1 (instead of !TM_FALSE) to utilize the Trimedia
**  processor hardware architecture.  Two TM CPU registers are hardwired to
**  represent the Bool values:  r0 = 0 (TM_FALSE) and r1 = 1 (TM_TRUE).
*/
#define TM_FALSE            0       /* replaces legacy False macro */
#define TM_TRUE             1       /* replaces legacy True  macro */

/*
** NOTE: Runtime endian byte-order defines
**  These defines are used for runtime little/big-endian byte-order checks
**  (as compared with the TMFL_ENDIAN_XXX flags defined in tmFlags.h, which
**  are only valid at build time and whose big/little-endian values are
**  reversed compared with these defines).
*/
#define TM_ENDIAN_BIG       0       /* replaces legacy BigEndian    macro */
#define TM_ENDIAN_LITTLE    1       /* replaces legacy LittleEndian macro */

/* NOTE: Nexperia common data types
**  The common data types used in Nexperia development (UInt32, Int8, etc.)
**  are defined either directly by this file or indirectly through inclusion
**  of the Trimedia Compilation and Simulation system (TCS) tmtypes.h header
**  file.  If the build flag __TCS__ is defined, it indicates a TCS-based
**  build, so the TCS-provided tmtypes.h file will be used (guaranteeing
**  compatibility).  If the __TCS__ build flag is not defined, TCS may not
**  be present and therefore the standard data types defined below will be
**  used, if they have not already been defined.
**
** NOTE 2:  This version of tmNxTypes.h has not been tested with old versions
**  of TCS.  (Potential problems may exist with TM applications that use
**  (1) 64-bit types, (2) a very old version of TCS [i.e., one that does not
**  define 64-bit types in tmtypes.h], and (3) this header file, for example.)
*/
#ifdef  __TCS__                     /* TCS present/TriMedia build target */

#ifndef __linux__
#define __linux__       0         /* avoid TCS undefined preproc. warning */
#define TEMP__linux__             /* ...but undefine again after tmtypes.h */
#endif


#ifdef TEMP__linux__
#undef __linux__                  /* don't break Linux-aware builds */
#undef TEMP__linux__              /* don't pollute namespace unnecessarily */
#endif

#if (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))
#define TMFL_NATIVE_INT64   1     /* don't typedef 64-bit types again */

#define I64LIT(i) i##LL
#define U64LIT(u) u##ULL
#endif

#else /* ifndef __TCS__ */

#ifdef _TMtypes_h                   /* if TCS tmtypes.h was already included */

#if (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))
#define TMFL_NATIVE_INT64   1     /* don't typedef 64-bit types again */

#define I64LIT(i) i##LL
#define U64LIT(u) u##ULL
#endif

#else /* ifndef _TMtypes_h */       /* if TCS tmtypes.h not (yet) included */
#define _TMtypes_h                  /* (typedefs defined below) */

#ifndef False
#define False         (TM_FALSE)  /* NOTE: Legacy - use TM_FALSE instead */
#endif
#ifndef True
#define True          (TM_TRUE)   /* NOTE: Legacy - use TM_TRUE  instead */
#endif

#ifdef __cplusplus
#define Null          0
#else
#define Null          ((Void *) 0)
#endif

/*
** Standard Types
*/
typedef void            Void;       /* Void (typeless) */
/*typedef signed   char   Int8;   *//*  8-bit   signed integer */                   /* Type already defined in phStdTypes.h */
/*typedef signed   short  Int16;  *//* 16-bit   signed integer */                   /* Type already defined in phStdTypes.h */
/*typedef signed   long   Int32;  *//* 32-bit   signed integer */                   /* Type already defined in phStdTypes.h */
/*typedef unsigned char   UInt8;  *//*  8-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
/*typedef unsigned short  UInt16; *//* 16-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
/*typedef unsigned long   UInt32; *//* 32-bit unsigned integer */                   /* Type already defined in phStdTypes.h */
typedef float           Float;      /* 32-bit floating point */
/* typedef unsigned int    Bool;  *//* Boolean (True/False) */                      /* Type already defined in phStdTypes.h */
/*typedef char            Char;   *//* character, character array ptr */            /* Type already defined in phStdTypes.h */
typedef int             Int;        /* machine-natural integer */
typedef unsigned int    UInt;       /* machine-natural unsigned integer */
/*typedef char           *String; *//* Null-terminated 8-bit char str */            /* Type already defined in phStdTypes.h */

/*-----------------------------------------------------------------------------
** Legacy TM Types/Structures (Not necessarily DVP Coding Guideline compliant)
** NOTE: For Nexperia/DVP Coding Gudeline compliance, do not use these types.
*/
/* typedef char          *Address;   *//* Ready for address-arithmetic */          /* Type already defined in phStdTypes.h */
typedef char const    *ConstAddress;
typedef unsigned char  Byte;           /* Raw byte */
typedef float          Float32;        /* Single-precision float */
typedef double         Float64;        /* Double-precision float */
typedef void          *Pointer;        /* Pointer to anonymous object */
typedef void const    *ConstPointer;
typedef char const    *ConstString;

typedef Int             Endian;             /* NOTE: legacy - use tmEndian_t */
#define BigEndian       (TM_ENDIAN_BIG)     /* NOTE: use TM_ENDIAN_BIG */
#define LittleEndian    (TM_ENDIAN_LITTLE)  /* NOTE: use TM_ENDIAN_LITTLE */

/* Required by TMDownloader.h */
/* TM32 = 0 for compatibility!, allow many tm32 versions before TM64 */
typedef enum { TM32 = 0, TM3260, TM5250, TM2270, TM64=100 } TMArch;
extern char* TMArch_names[];

typedef struct tmVersion
{
    UInt8   majorVersion;
    UInt8   minorVersion;
    UInt16  buildVersion;
}   tmVersion_t, *ptmVersion_t;

#endif /* ifndef _TMtypes_h */
#endif /* ifdef  __TCS__ */

/*
** NOTE: Compiler version-dependent support
**  C/C++ compiler versions C99 and later support 64-bit signed/unsigned
**  integers and some special keywords (such as "restrict") natively.  As
**  the compiler version used to compile this header file can vary, some
**  preprocessor checks are done to determine if the features are supported,
**  are not supported and must be emulated, or must be disabled altogether.
**  The __STDC_VERSION__ compiler version number (if defined) is compared
**  with the expected compiler version.  If the compiler version is not
**  defined, it is assumed that the compiler does not support the features.
**
**  [Note:  this appears to be an overly strict assumption; many compilers do
**  not define it by default, despite supporting many or most C99 features.
**  GNU C 3.x defines it only with the command-line option "-std=c99".]
*/
#define TMFL_STDC_VERSION_C89   198912L /* C89 compiler version (simulated) */
#define TMFL_STDC_VERSION_C95   199409L /* C95 compiler version number */
#define TMFL_STDC_VERSION_C99   199901L /* C99 compliant if >= this version */

#define TMFL_MSC_VERSION_600    1200    /* Microsoft Visual C Version 6.00 */

#ifndef __STDC_VERSION__
#define __STDC_VERSION__      (TMFL_STDC_VERSION_C89) /* assume old comp. */
   /* FIXME:  should this be protected (i.e., undefined again later), too? */
#endif

#ifndef _MSC_VER
#define _MSC_VER              (1)     /* prevent undefined preproc warning */
#define TEMP_MSC_VER                  /* undefine again later! */
#endif

#ifndef __TCS_VERSION__
#define __TCS_VERSION__       (1)     /* prevent undefined preproc warning */
#define TEMP__TCS_VERSION__           /* undefine again later! */
#endif

/*-----------------------------------------------------------------------------
** 64-bit native vs. 64-bit emulation (via struct).
**
** Use native 64-bit integer math for compilers that have it.
** This can be enabled only when all explicit references to the hi and lo
** structure members are eliminated from client code. [see MSVC comments below]
**
** [NOTE:  Native 64-bit via "long long" should probably be the default, as in
** TCS's tmtypes.h, with 64-bit emulation triggered only by special ifdefs.]
*/

#ifndef TMFL_NATIVE_INT64  /* don't typedef 64-bit types if tmtypes.h did so */

/*  o __STDC_VERSION__ used for C99 support (see discussion above)
**  o __USE_ISOC99 and __GLIBC_HAVE_LONG_LONG added for Linux/GCC
**     compatibility (TCS and tmman32 requirement)
**  o sun/__SVR4 (a.k.a. Solaris/SPARC) and __hpux added for TCS (build-host)
**     compatibility
**  o _LONGLONG is defined by some older 64-bit compilers
**  o LLONG_MAX would be defined in <limits.h> and is arguably the safest and
**     most generic test ... should we go ahead and #include it above?
*/
#if     (__STDC_VERSION__ >= TMFL_STDC_VERSION_C99) ||                         \
        defined(__USE_ISOC99) ||                                               \
        defined(__GLIBC_HAVE_LONG_LONG) ||                                     \
        (defined(sun) && defined(__SVR4)) ||                                   \
        defined(__hpux) ||                                                     \
        defined(_LONGLONG) ||                                                  \
        defined(LLONG_MAX) ||                                                  \
	    (__GNUC__ == 3)    ||                                                  \
        (__GNUC__ == 4)

#define TMFL_NATIVE_INT64   1           /* Native 64-bit integer support */

#define I64LIT(i) i##LL
#define U64LIT(u) u##ULL

/* Type already defined in phStdTypes.h */
//typedef signed   long long int Int64;   /* 64-bit signed   integer */
//typedef unsigned long long int UInt64;  /* 64-bit unsigned integer */

#elif   (defined (_MSC_VER) && (_MSC_VER >= TMFL_MSC_VERSION_600))
/* NOTE: Microsoft Visual C 64-bit integer support
**  The Microsoft Visual C compiler, version 6.0 (and later), has native 64-bit
**  integer support.  As some code (legacy apps only) currently accesses the
**  emulated 64-bit integer structure .hi/.lo members directly (rather than
**  through macros), that code will not compile if the MSC 64-bit integer
**  support is enabled.  For this reason, the MSC 64-bit integer support
**  originally was disabled (commented out), but current NDK, TCS, and tmComm
**  (TMC) shared-code considerations are considered to have precedence.
*/

#define TMFL_NATIVE_INT64   1           /* Native 64-bit integer support */

#define I64LIT(i) i##i64
#define U64LIT(u) u##ui64

/* Type already defined in phStdTypes.h */
//typedef signed   __int64 Int64;         /* 64-bit signed   integer */
//typedef unsigned __int64 UInt64;        /* 64-bit unsigned integer */

#elif   (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310))

        /* Native Int64/UInt64 integer types are unconditionally defined in
         * newer versions of tmtypes.h, already included above when __TCS__
         * is defined.
         *
         * [Note that this sub-block actually will NOT BE REACHED because
         *  TMFL_NATIVE_INT64 is already defined to be 1 whenever we detect
         *  (or force) the prior inclusion of tmtypes.h and have TCS >= 3.10;
         *  this entire block is protected by #ifndef TMFL_NATIVE_INT64.] */

#define TMFL_NATIVE_INT64 1           /* Native 64-bit integer support */

#define I64LIT(i) i##LL
#define U64LIT(u) u##ULL

#else /* No native compiler support for long long int Int64/UInt64 data type */

/* NOTE: Int64/UInt64 integer emulation data structures
** The Int64/UInt64 data structures defined below are used to emulate 64-bit
** integer support when used with older compilers that don't support them
** natively.  The data structure members (hi/lo) should not be accessed
** directly by software as this prevents the code from being portable when
** being built by compilers that do support 64-bit integers natively.
** Instead, code should use tmArith.h (tmArith infrastructure component)
** which defines a set of macros for portable operations involving 64-bit
** integers (e.g., I64ADD, U64GT, U8CASTI64, F32CASTI64, etc.).
*/
#define TMFL_NATIVE_INT64   0           /* No native 64-bit integer support */

/*
 * I64LIT(), U64LIT() not available in this case.
 */

/* Type already defined in phStdTypes.h */
//typedef struct                          /* Int64: 64-bit signed integer */
//{
//        /* Get the correct endianness (this has no impact on any other part of
//            the system, but it may make memory dumps easier to understand). */
//#if     (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
//        Int32 hi; UInt32 lo;
//#else
//        UInt32 lo; Int32 hi;
//#endif
//}   Int64;

//typedef struct                          /* UInt64: 64-bit unsigned integer */
//{
//#if     (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
//        UInt32 hi; UInt32 lo;
//#else
//        UInt32 lo; UInt32 hi;
//#endif
//}   UInt64;

#endif /* (defined(__TCS_VERSION__) && (__TCS_VERSION__ >= 310)) */
       /* (defined (_MSC_VER) && (_MSC_VER >= TMFL_MSC_VERSION_600)) */
       /* (__STDC_VERSION__ >= TMFL_STDC_VERSION_C99) ||
          defined(__USE_ISOC99) ||
          defined(__GLIBC_HAVE_LONG_LONG) ||
          (defined(sun) && defined(__SVR4)) ||
          defined(__hpux) ||
          defined(_LONGLONG) ||
          defined(LLONG_MAX) */

#endif /* ifndef TMFL_NATIVE_INT64 */

#ifdef TEMP_MSC_VER
#undef _MSC_VER                       /* don't break MSVC-aware builds */
#undef TEMP_MSC_VER
#endif

#ifdef TEMP__TCS_VERSION__
#undef __TCS_VERSION__                /* don't break TCS-aware builds */
#undef TEMP__TCS_VERSION__
#endif

/* Define DVP types that are not TCS types.
** NOTE: IBits32/UBits32 types are defined for use with 32-bit bitfields.
**       This is done because ANSI/ISO compliant compilers require bitfields
**       to be of type "int" else a large number of compiler warnings will
**       result.  To avoid the risks associated with redefining Int32/UInt32
**       to type "int" instead of type "long" (which are the same size on 32-
**       bit CPUs) separate 32-bit signed/unsigned bitfield types are defined.
*/
typedef signed   int    IBits32;    /* 32-bit   signed integer bitfields */
typedef unsigned int    UBits32;    /* 32-bit unsigned integer bitfields */

/*typedef Int8    *pInt8;         *//*  8-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef Int16   *pInt16;        *//* 16-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef Int32   *pInt32;        *//* 32-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef Int64   *pInt64;        *//* 64-bit   signed integer ptr */               /* Type already defined in phStdTypes.h */
typedef IBits32 *pIBits32;          /* 32-bit   signed integer bitfield ptr */
typedef UBits32 *pUBits32;          /* 32-bit unsigned integer bitfield ptr */
/*typedef UInt8   *pUInt8;        *//*  8-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef UInt16  *pUInt16;       *//* 16-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef UInt32  *pUInt32;       *//* 32-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
/*typedef UInt64  *pUInt64;       *//* 64-bit unsigned integer ptr */               /* Type already defined in phStdTypes.h */
typedef Void    *pVoid;             /* Void (typeless) ptr */
typedef Float   *pFloat;            /* 32-bit floating point, float ptr */
typedef double  Double, *pDouble;   /* 32/64-bit floating point, double ptr */
/*typedef Bool    *pBool;         *//* Boolean (True/False) ptr */                  /* Type already defined in phStdTypes.h */
/*typedef Char    *pChar;         *//* character, character array ptr */            /* Type already defined in phStdTypes.h */
typedef Int     *pInt;              /* machine-natural integer ptr */
typedef UInt    *pUInt;             /* machine-natural unsigned integer ptr */
/*typedef String  *pString;       *//* Null-terminated 8-bit char str ptr */        /* Type already defined in phStdTypes.h */

typedef Int     tmEndian_t, *ptmEndian_t;   /* replaces legacy Endian type */

/* Maximum length of device name in all DVP BSL and capability structures */
#define HAL_DEVICE_NAME_LENGTH  16

/*typedef UInt32 tmErrorCode_t;*/                                                   /* Type already defined in phStdTypes.h */
typedef UInt32 tmProgressCode_t;

/* timestamp definition */
typedef UInt64 tmTimeStamp_t, *ptmTimeStamp_t;

/* for backwards compatibility with the older tmTimeStamp_t definition */
#define ticks   lo
#define hiTicks hi

typedef union tmColor3                 /* 3-byte color structure */
{
    UBits32 u32;
#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
    struct {
        UBits32       : 8;
        UBits32 red   : 8;
        UBits32 green : 8;
        UBits32 blue  : 8;
    } rgb;
    struct {
        UBits32   : 8;
        UBits32 y : 8;
        UBits32 u : 8;
        UBits32 v : 8;
    } yuv;
    struct {
        UBits32   : 8;
        UBits32 u : 8;
        UBits32 m : 8;
        UBits32 l : 8;
    } uml;
#else /* (TMFL_ENDIAN == TMFL_ENDIAN_LITTLE) */
    struct {
        UBits32 blue  : 8;
        UBits32 green : 8;
        UBits32 red   : 8;
        UBits32       : 8;
    } rgb;
    struct {
        UBits32 v : 8;
        UBits32 u : 8;
        UBits32 y : 8;
        UBits32   : 8;
    } yuv;
    struct {
        UBits32 l : 8;
        UBits32 m : 8;
        UBits32 u : 8;
        UBits32   : 8;
    } uml;
#endif /* (TMFL_ENDIAN == TMFL_ENDIAN_BIG) */
}   tmColor3_t, *ptmColor3_t;

typedef union tmColor4                 /* 4-byte color structure */
{
    UBits32 u32;
#if (TMFL_ENDIAN == TMFL_ENDIAN_BIG)
    struct {
        UBits32 alpha    : 8;
        UBits32 red      : 8;
        UBits32 green    : 8;
        UBits32 blue     : 8;
    } argb;
    struct {
        UBits32 alpha    : 8;
        UBits32 y        : 8;
        UBits32 u        : 8;
        UBits32 v        : 8;
    } ayuv;
    struct {
        UBits32 alpha    : 8;
        UBits32 u        : 8;
        UBits32 m        : 8;
        UBits32 l        : 8;
    } auml;
#else /* (TMFL_ENDIAN == TMFL_ENDIAN_LITTLE) */
    struct {
        UBits32 blue     : 8;
        UBits32 green    : 8;
        UBits32 red      : 8;
        UBits32 alpha    : 8;
    } argb;
    struct {
        UBits32 v        : 8;
        UBits32 u        : 8;
        UBits32 y        : 8;
        UBits32 alpha    : 8;
    } ayuv;
    struct {
        UBits32 l        : 8;
        UBits32 m        : 8;
        UBits32 u        : 8;
        UBits32 alpha    : 8;
    } auml;
#endif /* (TMFL_ENDIAN == TMFL_ENDIAN_BIG) */
}   tmColor4_t, *ptmColor4_t;

/*-----------------------------------------------------------------------------
** Hardware device power states
*/
typedef enum tmPowerState
{
    tmPowerOn,                          /* Device powered on      (D0 state) */
    tmPowerStandby,                     /* Device power standby   (D1 state) */
    tmPowerSuspend,                     /* Device power suspended (D2 state) */
    tmPowerOff                          /* Device powered off     (D3 state) */

}   tmPowerState_t, *ptmPowerState_t;

/*-----------------------------------------------------------------------------
** Software Version Structure
*/
typedef struct tmSWVersion
{
    UInt32      compatibilityNr;        /* Interface compatibility number */
    UInt32      majorVersionNr;         /* Interface major version number */
    UInt32      minorVersionNr;         /* Interface minor version number */

}   tmSWVersion_t, *ptmSWVersion_t;

/*-----------------------------------------------------------------------------
** NOTE: This macro converts four characters into a UInt32 value.  It is used
**       instead of multi-character constants (i.e. 'ABCD') to prevent some
**       compiler warnings, especially with GNU-based compilers.
*/
#define TM_CHARS_TO_UINT32(a,b,c,d) ((UInt32) ((UInt8) (a) << 24 | (UInt8) (b) << 16 | (UInt8) (c) << 8 | (UInt8) (d)))

/* NOTE: TCS tmBoardDef.h
**  tmNxTypes.h duplicates many of the same typedefs that are defined in the
**  Trimedia Compilation and Simulation system (TCS) tmBoardDef.h header file
**  so there is no requirement that TCS be installed on a development system.
**  To prevent type definition conflicts when both header files are used by a
**  source file, the check for _TMBOARDDEF_H_ is done.  Whichever header file
**  (tmNxTypes.h or TCS tmBoardDef.h) is included first will define the
**  shared types and define _TMBOARDDEF_H_, thereby excluding the type
**  definitions in the other header file.
*/
#ifndef _TMBOARDDEF_H_                  /* tmBoardDef.h not included (yet) */
#define _TMBOARDDEF_H_                  /* exclude tmBoardDef.h defines */

/*-----------------------------------------------------------------------------
** HW Unit Selection
*/
typedef Int tmUnitSelect_t, *ptmUnitSelect_t;

#define tmUnitNone (-1)
#define tmUnit0    0
#define tmUnit1    1
#define tmUnit2    2
#define tmUnit3    3
#define tmUnit4    4

/*+compatibility*/
#define unitSelect_t       tmUnitSelect_t
#define unit0              tmUnit0
#define unit1              tmUnit1
#define unit2              tmUnit2
#define unit3              tmUnit3
#define unit4              tmUnit4
#define DEVICE_NAME_LENGTH HAL_DEVICE_NAME_LENGTH
/*-compatibility*/

#endif /* ifndef _TMBOARDDEF_H_ */

/* Additional tmUnitSelect_t defines (not duplicated in TCS tmBoardDef.h) */
#define tmUnit5    5
#define tmUnit6    6
#define tmUnit7    7

/*-----------------------------------------------------------------------------
** Instance handle
*/
typedef Int tmInstance_t, *ptmInstance_t;

/* Callback function declaration */
typedef Void (*ptmCallback_t) (UInt32 events, Void *pData, UInt32 userData);
#define tmCallback_t ptmCallback_t /*compatibility*/

#if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)

/*-----------------------------------------------------------------------------
** Shared data segment macro - Places shared data in named DLL data segment.
** WinNT/WinCE: Use TMSHARED_DATA_BEGIN/TMSHARED_DATA_END for multiprocess
**  shared data on a single CPU.  To define data variables that are shared
**  across all processes for WinNT/WinCE, use the defined #pragma macros
**  TMSHARED_DATA_BEGIN/TMSHARED_DATA_END and initialize the data variables
**  as shown in the example below.  Data defined outside of the begin/end
**  section or not initialized will not be shared across all processes for
**  WinNT/WinCE; there will be a separate instance of the variable in each
**  process.  Use WinNT Explorer "QuickView" on the target DLL or text edit
**  the target DLL *.map file to verify the shared data section presence and
**  size (shared/static variables will not be named in the MAP file but will
**  be included in the shared section virtual size).
** NOTE: All data variables in the multiprocess section _MUST_BE_INITIALIZED_
**       to be shared across processes; if no explicit initialization is
**       done, the data variables will not be shared across processes.  This
**       shared data mechanism only applies to WinNT/WinCE multiprocess data
**       on a single CPU (pSOS shares all data across tasks by default).  Use
**       the TMML MP shared data region for shared data across multiple CPUs
**       and multiple processes.  Example (note global variable naming):
**
**  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
**  #pragma TMSHARED_DATA_BEGIN         // Multiprocess shared data begin
**  #endif
**
**  static g<Multiprocess shared data variable> = <Initialization value>;
**         gtm<Multiprocess shared data variable> = <Initialization value>;
**
**  #if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)
**  #pragma TMSHARED_DATA_END           // Multiprocess shared data end
**  #endif
**
** NOTE: These pragma defines require that the DLL flags include the following
**       line: "-section:.tmShare,RWS" in the makelib.mk and maketarget.mk
**       (or equivalent) target OS makefiles for this mechanism to work.
*/
#define TMSHARED_DATA_BEGIN     data_seg(".tmShare")
#define TMSHARED_DATA_END       data_seg()

#endif /* (TMFL_OS_IS_CE || TMFL_OS_IS_NT) */

#if     (!(defined __TCS__) && (__STDC_VERSION__ < TMFL_STDC_VERSION_C99))

/*-----------------------------------------------------------------------------
** 'C' language keywords
** ---------------------
**  [inline]
**  The Trimedia Compilation and Simulation system (TCS) compiler and also
**  C99 or later compilers support the "inline" keyword.  For non-TCS and
**  pre-C99 compilant compilers, the "inline" keyword is mapped to the native
**  compiler's equivalent keyword.  The inline keyword is excluded if this
**  header file is being compiled in a C++ environment (__cplusplus defined).
**
**  [restrict]
**  The "restrict" keyword (e.g., UInt32 * restrict pData) tells the 'C'
**  compiler that within the scope of this pointer, no other pointer will
**  alias to the same memory location (i.e., the only way to access the data
**  is through this pointer), allowing the compiler to perform certain code
**  optimizations.  The "restrict" keyword is supported by the Trimedia
**  Compilation and Simulation system (TCS) tmcc compiler and by C99 and
**  later compiler versions.  If the compiler doesn't support "restrict," the
**  keyword is defined as blank (nothing).
*/
#if     (TMFL_OS_IS_CE || TMFL_OS_IS_NT)

#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
#define inline      __inline
#endif /* (!defined __cplusplus) */

#define restrict    /**/

#elif      TMFL_OS_IS_PSOS && TMFL_CPU_IS_MIPS

/* NOTE regarding the keyword INLINE:
**
** Inline is not an ANSI-C keyword, hence every compiler can implement inlining
** the way it wants to. When using the dcc compiler this might possibly lead to
** redeclaration warnings when linking. For example:
**
**      dld: warning: Redeclaration of tmmlGetMemHandle
**      dld:    Defined in root.o
**      dld:    and        tmmlApi.o(../../lib/pSOS-MIPS/libtmml.a)
**
** For the dcc compiler inlining is not on by default. When building a retail
** version ( _TMTGTREL=ret), inlining is turned on explicitly in the dvp1 pSOS
** makefiles by specifying -XO, which enables all standard optimizations plus
** some others, including inlining (see the Language User's Manual, D-CC and
** D-C++ Compiler Suites p46). When building a debug version ( _TMTGTREL=dbg),
** the optimizations are not turned on (and even if they were they would have
** been overruled by -g anyway).
**
** When a .h file with inline function declarations gets included in multiple
** source files, redeclaration warnings are issued.
**
** When building a retail version those functions are inlined, but in addition
** the function is also declared within the .o file, resulting in redeclaration
** warnings as the same function is also defined by including that same header
** file in other source files. Defining the functions as static inline rather
** than inline solves the problem, as now the additional function declaration
** is omitted (as now the compiler realizes that there is no point in keeping
** that declaration as it can only be called from within this specific file,
** but it isn't, because all calls are already inline).
**
** When building a debug version no inlining is done, but the functions are
** still defined within the .o file, again resulting in redeclaration warnings.
** Again, defining the functions to be static inline rather than inline solves
** the problem.
**
** Now if we would change the definition of the inline keyword for pSOS from
** __inline__ to static __inline__, all inline function definitions throughout
** the code would not issue redeclaration warnings anymore, but all static
** inline definitions would.
** If we don't change the definition of the inline keyword, all inline func-
** tion definitions would return redeclaration warnings.
**
** As this is a pSOS linker bug, it was decided not to change the code but
** rather to ignore the issued warnings.
*/
#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
#define inline      __inline__
#endif /* (!defined __cplusplus) */

#define restrict    /**/

#elif   (TMFL_OS_IS_PSOS && TMFL_CPU_IS_TM)
/* TCS supports the "inline"   keyword */
/* TCS supports the "restrict" keyword */

#elif   (TMFL_OS_IS_VXWORKS || TMFL_OS_IS_HPUNIX || TMFL_OS_IS_NULLOS)
/*
** TMFL_OS_IS_HPUNIX is the HP Unix workstation target OS environment for the
** DVP SDE2 using the GNU gcc toolset.  It is the same as TMFL_OS_IS_NULLOS
** (which is inaccurately named because it is the HP Unix CPU/OS target
** environment).
** TMFL_OS_IS_VXWORKS is the VxWorks build which also uses the GNU toolset.
** TMFL_OS_IS_LINUX is the Linux build which also used the GNU toolset.
*/
#if     (!defined __cplusplus)          /* Exclude keyword if C++ build */
#define inline      __inline__
#endif /* (!defined __cplusplus) */

#define restrict    /**/

#elif   (TMFL_OS_IS_LINUX)

#else /* TMFL_OS_IS_??? */

#error ERROR: Unrecognized/unsupported TMFL_OS_IS_XXX value !

#endif /* TMFL_OS_IS_XXX */
#endif /* (!(defined __TCS__) && (__STDC_VERSION__ < TMFL_STDC_VERSION_C99)) */

#ifdef __cplusplus
}
#endif

#endif /* ifndef TMNXTYPES_H */

